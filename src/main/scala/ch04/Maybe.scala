
/* 
f :: A -> ()
f' :: B -> ()

where B <: A (B is subtype A)

{
  // code ...
  do {
    val value: B = ???
    f'( value ) // ok
    // but
    f( value ) // ok
  }

  do {
    val value: A = ???
    f'( value ) // fail
    f( value ) // ok
  }
}

substitution principle

A >: B - `A`  is super type `B`, ( там где, ожидается тип A, можно туда передать объект типа B)
потому что B имеет все методы, которые есть у объектов типа A, + еще что-то.
Но, если посмотреть на поведение функций, которые принимают на вход параметры разного типа и которые
состоят в наследовании, то видно, что направление взаимозаменяемости изменилось. Родительская функция
(функция с супертипом) может использоваться во всех случаях, где может быть использована функция с 
дочерними типами, но не наоборот.

f' <: f - другое направление


Предположим, имеется фрагмент кода, который совершает вызов функции. Функция принимает на вход
один аргумент и возвращает вычисленное значение. 

code snippet (ВНИМАНИЕ! типы `A` и `B` никак не связаны.)

{
  // define function from 'A' to 'B'
  def f(value: A): B = { ... }

  val value: A = "type value is A"
  // give me value of type `A` and it returns value of type `B`
  val result: B = f( value )
  // we wait value of type `B`, therefore call method which exists define class `B`
  result.callAsB()
}

Проведем небольшой эксперимент. Проверим код на прочность. Вопрос, какие функции можно подставить
в код выше вместо функции `f`, так чтобы не возникла ошибка. Т.к. речь идет об `ковариантности` и 
`контрвариантности`, то интерес, прежде всего, лежит в области типизации функции. Согласно правилу
подстановки супертипов и подтипов, в операции присваивания, там где ожидается супертип, можно 
безболезненно передать объект подтипа. (Экземпляры подтипа имеет все методы супертипа + могут
реализовать дополнительный функционал). Применим данное правило:

{
  // define function from 'A' to `:<B`
  def g(value: A): ?<:B = { ... }
  
  val value: A = "type value of A"
  val result: B = g(value)
  result.callAsB()
}

В коде выше запись вида `?<:B`, означает значение подтипа `B`. Т.е. что-то что наследует у типа `B`,
находится ниже в иерархии наследование, чем `B`. Код валиден, потому что соблюдается правило 
подставновки супертипов и подтипов. Ожидаем тип `B`, получаем объект-подтип `B`, который умеет делать
все то же самое, даже возможно больше. 
Обратите внимание, обратное не верно. Использовать тип `?>:B`, который является супертипом для `B`
нельзя. 
Таким образом, для нас открылся целый список функций, которые могут подминить нашу первоначальную 
версию - это все функции с тоже сигнатурой на входе, но подтипом на выходе. Наблюдается
свойство ковариантности по возвращаемому параметру. 

B - super type ?<:B - subtype. (<:B можно использовать там, где ожидается B)
f :: A => B - function from A to B and g :: A => :<B (функция g может заменить f)

Направление подстановки сохраняется. (что-то может быть заменено чем-то)
B -> (читай может быть заменено на) ?<:B
A => B -> (читай может быть заменено на) A => ?<:B

Подобный трюк проделаем и с входным параметром. 

{
  // define function from '?>:A` to `B`
  def g(value: ?>:A): B = { ... }
  
  val value: A = "type value of A"
  val result: B = g(value)
  result.callAsB()
}

 */
